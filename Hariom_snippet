
{
"cfsnip": {
  "prefix": "cfsnip",
  "body": [
    "#include \"bits/stdc++.h\"",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace std;",
    "using namespace __gnu_pbds;",
    "#define gc getchar_unlocked",
    "#define int long long ",
    "#define ll long long ",
    "#define rep(i, a, b) for (int i = a; i < b; i++)",
    "#define each(i, k, n) for (int i = k; i <= n; i++)",
    "#define pb push_back",
    "#define endl '\\n'",
    "#define ff first",
    "#define ss second",
    "typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key",
    "int min(int a, int b) { if (a < b) return a; return b; }",
    "int expo(int a, int b, int mod) { int res = 1; while (b > 0) { if (b & 1) res = (res * a) % mod; a = (a * a) % mod; b = b >> 1; } return res; }",
    "typedef pair<int, int> pii;",
	"typedef pair<int, int> pl;",
    "typedef vector<int> vl;",
	"typedef vector<int> vi;",
    "typedef vector<pii> vpl;",
    "typedef vector<vi> vvi;",
    "void setIO(string name = \"\") {",
    "    if (name.size()) {",
    "        freopen((name + \".in\").c_str(), \"r\", stdin);",
    "        freopen((name + \".out\").c_str(), \"w\", stdout);",
    "    }",
    "}",
    "template<typename A>",
    "istream& operator>>(istream& fin, vector<A>& v) {",
    "    for (auto it = v.begin(); it != v.end(); ++it)",
    "        fin >> *it;",
    "    return fin;",
    "}",
    "template<typename A>",
    "ostream& operator<<(ostream& out, vector<A>& v) {",
    "    for (auto it = v.begin(); it != v.end(); ++it)",
    "        out << *it << ' ';",
    "    return out;",
    "}",
    "int max(int a, int b) { if (a > b) return a; return b; }",
    "void chmax(int &a, int b) { a = max(a, b); }",
    "int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }",
    "int mod_add(int a, int b, int m) { a = a % m; b = b % m; return (((a + b) % m) + m) % m; }",
    "int mod_mul(int a, int b, int m) { a = a % m; b = b % m; return (((a * b) % m) + m) % m; }",
    "int mod_sub(int a, int b, int m) { a = a % m; b = b % m; return (((a - b) % m) + m) % m; }",
    "int mminvprime(int a, int b) { return expo(a, b - 2, b); }",
    "int mod_div(int a, int b, int m) { a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m; }  // only for prime m",
    "void _print(int t) { cerr << t; }",
    "void _print(string t) { cerr << t; }",
    "void _print(char t) { cerr << t; }",
    "template <class T, class V> void _print(pair<T, V> p);",
    "template <class T> void _print(vector<T> v);",
    "template <class T> void _print(set<T> v);",
    "template <class T, class V> void _print(map<T, V> v);",
    "template <class T> void _print(multiset<T> v);",
    "template <class T, class V> void _print(pair<T, V> p) { cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\"; }",
    "template <class T> void _print(vector<T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\\n\"; }",
    "template <class T> void _print(set<T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\\n\"; }",
    "template <class T> void _print(multiset<T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\\n\"; }",
    "template <class T, class V> void _print(map<T, V> v) { cerr << \"[ \"; for (auto i : v) { _print(i); cerr << \" \"; } cerr << \"]\\n\"; }",
    "int lcm(int a, int b) { return a / gcd(a, b) * b; }",
    "string to_upper(string a) { for (int i = 0; i < (int)a.size(); ++i) if (a[i] >= 'a' && a[i] <= 'z') a[i] -= 'a' - 'A'; return a; }",
    "string to_lower(string a) { for (int i = 0; i < (int)a.size(); ++i) if (a[i] >= 'A' && a[i] <= 'Z') a[i] += 'a' - 'A'; return a; }",
    "bool prime(int a) { if (a == 1) return 0; for (int i = 2; i <= round(sqrt(a)); ++i) if (a % i == 0) return 0; return 1; }",
    "#define mod 1000000007",
    "vi fact(200005), ifact(200005);",
    "const int N = 2e5 + 10;",
    "void calculate_factorials() {",
    "    fact[0] = 1;",
    "    for (int i = 1; i < N; i++) {",
    "        fact[i] = mod_mul(fact[i - 1], i, mod);",
    "    }",
    "    ifact[N - 1] = mminvprime(fact[N - 1], mod);",
    "    for (int i = N - 2; i >= 0; i--) {",
    "        ifact[i] = mod_mul(i + 1, ifact[i + 1], mod);",
    "    }",
    "}",
    "int nCr(int x, int y) {",
    "    if (y > x) { return 0; }",
    "    int num = fact[x]; num *= ifact[y]; num %= mod; num *= ifact[x - y]; num %= mod; return num;",
    "}",
    "#define all(x) x.begin(), x.end()",
    "#define sortall(x) sort(all(x))",
    "#define tr(it, a) for (auto it = a.begin(); it != a.end(); it++)",
    "#define PI 3.1415926535897932384626",
    "#define sz(z) z.size()",
    "const int inf = 1e15;",
    "inline void solve() {",
	"",
    "    $0",
	"",
	"",
    "}",
    "signed main() {",
	"",
    "    ios_base::sync_with_stdio(0);",
    "    cin.tie(0);",
    "    cout.tie(0);",
	"",
    "    int t = 1;",
    "    cin >> t;",
	"",
    "    while (t--) {",
    "        solve();",
    "        cout << endl;",
    "    }",
    "    return 0;",
    "}",
    ""
  ],
  "description": "cfsnip"
},

"fenwick": {
  "prefix": "fenwick",
  "body": [
    "struct Fenwick {",
    "    int n;",
    "    vector<long long> bit;",
    "    Fenwick() {}",
    "    Fenwick(int _n) { init(_n); }",
    "    void init(int _n) { n = _n; bit.assign(n+1, 0); } // n is max index (use n = size)",
    "    void add(int idx, long long val) { // idx is 1-based",
    "        while (idx <= n) {",
    "            bit[idx] += val;",
    "            if (bit[idx] >= mod) bit[idx] -= mod;",
    "            idx += idx & -idx;",
    "        }",
    "    }",
    "    long long sumPrefix(int idx) { // idx is 1-based",
    "        long long res = 0;",
    "        while (idx > 0) {",
    "            res += bit[idx];",
    "            if (res >= mod) res -= mod;",
    "            idx -= idx & -idx;",
    "        }",
    "        return res % mod;",
    "    }",
    "    long long query(int l, int r) { // l,r are 1-based, inclusive",
    "        if (l > r) return 0;",
    "        long long res = (sumPrefix(r) - sumPrefix(l-1)) % mod;",
    "        if (res < 0) res += mod;",
    "        return res;",
    "    }",
    "};"
  ],
  "description": "fenwick"
},
	"sieve": {
	"prefix": "sieve",
	"body": [
		"    rep(i,1,N){",
		"        spf[i] = i;",
		"    }",
		"    for(int i = 2;i < N;i += 2){",
		"        spf[i] = 2;",
		"    }",
		"    for(int i = 3;i * i <= N;i += 1){",
		"        if(spf[i] == i){",
		"            for(int j = i * i;j <= N;j += i){",
		"                if(spf[j] == j){",
		"                    spf[j] = i;",
		"                }",
		"            }",
		"        }",
		"    }"
	],
	"description": "sieve"
},
	  "FOR MIST": {
		"prefix": "mist",
		"body": [
		  "/*⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡴⠋⠀⡠⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠈⢇⠀⠀⠀⠀⠀⠀    ⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⠸⣿⣿⣿⠂⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠞⠀⢠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡄⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀    ⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⡀⡃⠈⠁⠂⠀⣸⠇⠀⠀⠀⠀⠀⠀⠀⠀⢠⠊⠀⠀⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⢙⠀⠀⠀⠀⠀⠀⠀     ⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣷⣾⣔⣘⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⡟⠀⠀⡘⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⣠⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠄⠀⠀⠘⠀⠀⠀⠀⠀⠀       ⢀⡠⡘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠸⠀⠀⠀⠇⠀⠀⠀⠀⠀⠀⢀⠎⠀⣰⣿⢳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀       ⢳⢱⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⡃⣤⠀⠸⠀⠀⠀⠀⠀⠠⢠⠍⢀⡴⠋⣿⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀       ⢀⢫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⢀⡇⣹⠀⠀⡀⠀⠀⠀⢀⣢⠋⣰⠋⠀⠀⢻⠘⢿⣀⡀⠀⢆⠀⠀⢰⠀⠀⠀⠀⠀⡇⠇⠀⠀⠀⠀       ⣆⠀⠘⡜⣿⣿⣿⣿⣿⡿⠻⣿⣿⣿⣿⣿⡟⠟⢛",
		  "⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⣼⠷⡛⡇⠀⠇⠀⣀⠀⡮⣏⠞⠙⠑⠢⢄⣈⣾⠈⢻⣷⡀⠈⡄⠀⠀⠀⠀⠀⡆⣸⣸⡇⠀⠀⠀⠀     ⣿⠀⢀⣿⣿⣿⣿⣿⣿⡇⠀⠁⠙⠋⠉⠙⠁⢿⣿",
		  "⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⢰⠋⡠⢷⣴⡀⣜⡀⠈⢿⡻⠻⢷⣾⣧⣴⣂⣬⣹⣷⣤⣙⣿⣆⢘⡀⠀⢀⣠⣼⣶⣧⢻⡇⠀    ⢸⠀⢰⣿⣾⡼⡟⠛⡿⡿⢿⠯⠆⢀⣟⣶⣄⣀⠢⣶⣿⣿",
		  "⣿⣿⣿⣿⣿⡿⠀⠠⠀⠀⠀⠀⢀⡇⠸⠥⢈⣿⣷⣼⣷⠀⢸⠟⣦⡈⠻⣿⣿⠿⠳⢿⡯⠉⠀⠉⠋⠻⣥⢾⣧⣼⢿⣿⡧⣿⡇⣠⣿⢤⣿⣿⢹⠋⠃⢀⣀⣀⣨⡥⣦⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⠿⣿⣿⣿⠇⠠⠇⢠⠃⠀⠀⡾⣷⡈⠾⡁⢰⡟⠻⣿⣿⣾⣦⡀⠉⠙⠒⠀⠈⠁⠀⠀⠀⠀⠀⠀⢰⣏⠿⠿⢿⡿⢟⡾⣹⢵⣿⣿⣿⣿⣿⠏⠾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⢓⣠⣤⣬⣼⠆⡜⠀⡐⠀⢀⠎⣰⣿⣷⣄⠳⢾⣇⠀⠀⡇⠻⣿⡛⠦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⡏⠀⠈⠉⠉⠁⢠⢯⣿⣿⣿⣿⣿⣧⣴⡒⠾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⣿⣿⡝⠀⡐⠀⠠⠏⢠⣿⣿⣿⡻⣷⣀⣿⠀⢸⡇⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠁⠀⠀⠀⠀  ⢠⣷⣿⠏⢻⣿⣿⣿⣿⡿⡧⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⣿⢟⠂⢰⠂⠀⠀⠰⠁⡾⡣⢲⡽⢱⣿⣿⠀⠸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀  ⣾⡟⠁⠀⠀⢻⣿⣏⢀⢥⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⣯⠂⢀⠆⠀⠀⡴⠁⣴⠉⡥⠛⢠⣿⣿⣼⠀⢰⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠀⠀⠀  ⢀⣼⢿⠀⠀⠀⠀⠠⣿⣿⠁⠁⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⣿⣿⡃⢀⡎⠀⠀⡜⢁⡜⣡⠖⠀⢀⣽⣿⣿⣿⠀⠘⢿⢳⣄⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣠⣤⠀⠀⠀⣠⣾⠁⢸⡀⠀⠀⠄⠀⠩⣿⡀⢀⣥⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⣿⡟⡜⠀⡜⠀⠀⠊⣠⣎⠜⠁⠀⣨⣿⣿⣿⣿⣿⡆⠀⣾⠀⠹⣷⣄⡀⠀⠀⠀⠉⠈⠉⠩⠭⠄⠀⠀⣠⣾⣿⣿⡆⠸⡇⠀⠀⢤⠀⠀⠈⢷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⡿⡝⠀⡜⠀⠀⢀⠄⠁⠁⠀⠀⢨⣿⣿⣿⣿⣿⣿⣇⠀⢻⣶⣄⡈⢻⣿⣶⣄⡀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⡇⠀⣿⠠⠀⢸⡄⣂⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⠩⠁⣸⠃⢀⡔⠋⠀⢀⣀⠞⢡⣿⣿⣿⣿⣿⣿⣿⣿⡀⢸⣿⣿⣿⣷⣿⣿⣿⣿⣷⣤⣀⣀⣶⣿⣿⣿⣿⣿⣿⣿⣿⡀⢻⡆⢣⠀⢷⡸⣢⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⢁⣼⢎⡔⠈⣠⣾⠁⣼⠏⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢸⣿⡄⢧⠈⡧⠑⣕⣄⠀⠀⠀⠙⢻⣿⣿⣿⣿⣿⣿⡿⢿⡿⠛⠛⠙",
		  "⣾⢯⠎⣠⣾⣿⢃⢪⠏⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢿⣿⣿⣿⣿⣿⣿⣿⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣮⢢⠹⣆⠘⠻⣷⣄⠀⠀⠀⠙⠻⢿⣿⠛⠀⣀⣀⣤⣦⡆⠀",
		  "⣻⠇⣴⣿⣿⡧⡼⠻⠀⡌⣿⣿⣿⣿⣿⣿⣟⠿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⢷⣷⣿⣷⣄⠈⠛⠷⣤⡀⠀⠀⠀⠙⠓⠻⢿⣿⣿⣿⣿⣧",
		  "⡿⣸⠾⡟⠍⠊⠀⡆⠀⢡⣿⣿⣿⣿⣿⣿⣿⡀⠈⠻⢿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⡀⠀⠀⠀⠈⢷⠰⠄⡀⠉⠓⠦⣀⠀⠀⠀⠀⠈⠉⠒⠰⠆",
		  "⠻⠑⠈⠀⠀⠀⢠⡇⠀⢸⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠈⠹⣟⠿⠿⠿⠟⠁⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⢀⠳⣖⠮⠢⣄⠀⠀⠉⡒⠦⠤⣀⡀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⢀⣿⣧⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠈⢉⠀⠀⠀⠁⠀⢠⠀⠀⠀⠀⢀⡸⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⢸⠀⠙⣆⠲⣌⠳⣤⡀⠈⠒⠆⡀⠀⠉⠉⠲",
		  "⠀⠀⠀⠀⢀⣾⣿⣿⣆⢩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠡⠀⠀⠀⠀⠀⠂⢀⣤⠒⠁⠀⢻⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠀⠀⢸⡷⣌⠳⣌⠙⢦⣀⠀⠀⠑⢤⢀⠀",
		  "⠀⠀⠀⠀⣾⣿⣿⣿⣿⡦⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣍⠁⠐⠒⠒⢦⣤⠀⠀⠀⠀⠊⠀⠀⠀⠀⠘⣿⣿⣿⣷⣶⣶⣤⣤⣤⣄⣀⠀⠀⠀⠀⣀⠀⠀⠀⣿⣮⣳⢬⡳⣄⡈⠓⣤⡀⠀⢈⡑",
		  "⠀⠀⠀⠚⠛⠉⠉⠉⠉⠉⠻⣍⠉⠉⠛⠛⠿⢿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡭⠀⠿⠀⠀⠀⠘⣿⣿⣷⣭⣪⣕⣦⣀⣨⣷⣿⡇",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠦⠀⠀⠀⠀⠀⣠⣽⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣯⣉⢻⣿⡧⢀⢠⠀⠀⠀⠀⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⣤⣖⣀⣀⣉⠟⠃⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣧⣾⣿⣧⡹⠸⠀⠀⠀⠀⡵⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣟",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠁⠀⠀⢈⡙⢧⠃⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢿⡁⡄⠀⠀⠀⠣⠃⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠁⠈⠃⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠙⣇⠀⠀⠀⢀⡀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⠀⠉⠲⣄⠀⠀⠀⠀⠀⠰⣿⣿⣿⣿⣿⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠠⡀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⣀⠀⢸⣷⢄⠀⢸⠅⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿",
		  "⠀⠀⠀⠀⠑⠤⡀⠀⡛⢛⡺⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠙⣄⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⠃⠀⢿⡷⠸⠛⠀⢷⢁⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀*/",
			
		],
		"description": "mist"
},
"input": {
  "prefix": "input",
  "body": [
    ">>"
  ],
  "description": "input"
},
"bracket": {
  "prefix": "bracket",
  "body": [
    "()"
  ],
  "description": "bracket"
},

"parenthesis": {
  "prefix": "parenthesis",
  "body": [
    "()"
  ],
  "description": "parenthesis"
},
"au": {
  "prefix": "auuu",
  "body": [
    "o"
  ],
  "description": "auuu"
},
"el": {
  "prefix": "aee",
  "body": [
    "l"
  ],
  "description": "aee"
},
"faur": {
  "prefix": "faur",
  "body": [
    "for(int i = 0;i < n;i += 1)"
  ],
  "description": "faur"
},

"takeinput": {
  "prefix": "takeinput",
  "body": [
    "cin >>"
  ],
  "description": "takeinput"
},

"greater": {
  "prefix": "greater",
  "body": [
    ">"
  ],
  "description": "greater"
},

"print": {
  "prefix": "print",
  "body": [
    "cout << "
  ],
  "description": "print"
},




	  "FOR AYANO": {
		"prefix": "kiyotaka",
		"body": [
		  "/*⡯⣽⢩⠯⣝⣭⣻⢭⠷⡽⣚⡳⣝⢫⡟⡽⢫⣽⣭⣷⣽⣿⣿⣿⣿⣿⣿⣭⣯⣝⣯⢻⣝⡻⣽⢻⣭⣛⠿⣭⢯⡽⣯⣽⢭⢯⡝⡯⣝⢯",
		  "⢷⣊⠷⣫⠝⢦⡟⣬⠳⣱⢣⠳⣌⢧⣛⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣯⡝⣳⣝⡳⢮⡹⣞⡵⣫⢞⣵⢮⢏⡷⣹⢳⣛⢮",
		  "⢇⢎⡱⠥⡛⢆⠯⣐⢣⡑⢎⡱⢌⡼⣫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⡷⣜⣟⢧⣛⠶⣭⣓⢯⣚⡯⡞⣵⢫⠷⣹⢎",
		  "⠊⠔⠨⠑⢌⡺⠑⠌⢢⠘⠤⢘⠸⣹⣿⣿⣟⣿⣟⡿⠟⡋⠟⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣟⢮⣭⢛⡶⣹⢎⡷⣫⣝⢮⣏⡽⣣⢯",
		  "⠀⠀⠁⠈⠂⡅⠌⡠⢁⣌⠐⠄⢢⣿⣟⣷⣿⣻⣾⣏⠐⠀⠀⠀⢿⣹⣿⣿⣿⣿⣿⣿⣿⣿⣷⢿⡾⡴⢯⡞⣵⣫⢶⣹⢎⡷⣪⢵⣫⢞",
		  "⠀⠀⠀⠀⢰⠀⠀⠀⠀⠈⠐⠂⢸⢿⠮⣽⡿⣽⣾⣿⡆⠀⠀⠀⢹⢛⣿⣸⢿⣿⣿⣿⣿⣿⣿⣯⡿⣝⠮⣝⠶⣹⢮⡝⣯⢳⣛⢮⠷⣞",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢦⢺⢇⡹⡿⣻⡗⢷⡫⡠⠀⠀⠀⠿⣷⣾⡟⢻⣿⣿⣿⣿⣟⣛⡷⢎⡻⢬⣛⣥⢳⡝⣾⢣⡟⢮⡻⣜",
		  "⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⣸⢃⡿⡔⣇⢙⠭⣶⢏⠐⠀⠀⠀⠀⠈⠁⠀⢠⡿⢿⡿⣿⣿⡹⢾⣡⢏⡳⠼⣬⢳⡹⢞⣧⣛⢧⡻⣜",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢋⢾⠟⣷⣜⡌⠀⠉⠀⠀⠀⢦⠀⠀⠀⠀⠀⠉⢸⣙⡽⣭⢏⡿⡘⣆⢣⡝⢳⢬⠳⣭⢫⣗⠎⡷⣹⢎",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠠⠚⠋⡽⠒⡙⠂⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⣰⣾⠜⡡⢏⠲⢉⡇⠲⣌⠳⢎⡳⢥⡳⣹⢶⣙⠧⣏",
		  "⠀⠀⠀⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠠⠤⠮⢔⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡿⠼⢯⠴⠈⠐⣀⣇⠱⣈⣧⡙⡜⢣⢳⠹⣎⠮⣝⢮",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠲⣄⣀⠀⠀⠀⠀⠀⠊⣸⣁⡀⠈⠆⠀⠀⠀⢠⡒⠠⢂⠜⡩⢏⢎⡛⡧⣛⢎⠶",
		  "⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠻⣇⠀⠀⠐⠀⠀⡀⡋⠀⠰⣤⣀⠀⠀⠀⠸⠀⠑⠨⢠⠁⠎⡰⢈⢗⠌⡎⡱",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⠀⠀⣠⢴⣰⢿⡏⢀⡁⢅⠀⠀⠀⠸⢀⠁⡄⠀⢹⣶⣶⢶⣄⡀⠀⠀⠀⠀⠁⠂⡠⠁⢺⠈⠔⠡",
		  "⠀⠀⠁⠀⠀⠀⠀⠀⣠⢞⠯⣯⣙⢦⢫⡽⡣⢎⣳⢿⠀⣼⡌⢐⢤⡀⡠⠂⢠⣴⡷⢄⠈⣷⣯⡷⡝⠿⣳⠦⣤⣀⡀⠀⠀⠁⢀⠇⠈⠀",
		  "⠀⠀⠀⠀⠀⢀⣴⣿⣭⣞⣧⣛⣿⣮⣏⣰⢱⢫⣼⣇⠨⠘⣾⢦⣄⣄⢀⣼⣯⠟⠁⡄⠑⣽⢆⣳⠽⣨⢧⣛⠶⣝⣻⣷⡀⠀⠀⡀⠀⠀",
		  "⠀⠀⢀⡤⣶⢻⣝⢯⡞⣽⡶⠋⢋⡀⠐⠈⠱⣗⠾⡏⠀⠀⠀⢸⣯⣻⣽⠏⠐⠀⠀⢀⠘⢸⡞⢦⣉⡓⠧⣝⣺⡱⣏⣿⡆⠀⠀⠁⠀⠀",
		  "⠀⢀⣾⣷⣿⢻⣾⣽⣾⣏⡈⡀⡀⠀⠀⠀⠀⠈⢛⣧⠠⠄⠀⠈⣷⣯⠏⠀⠀⠀⠀⠈⠀⠈⣟⡼⢲⡹⠀⣞⡴⣻⡜⣾⡗⠀⠀⠘⠀⠀",
		  "⠀⣾⣽⣿⢹⣏⡟⣧⠳⣜⢭⢿⡇⠀⠀⠀⠀⠀⠈⢿⣂⡀⠂⢠⣿⣻⢸⠀⠀⠀⠀⠃⠀⠀⡿⣜⢧⣛⠘⣯⣾⢷⣹⣿⣇⣀⠀⠀⠀⠀",
		  "⠀⣿⣿⣿⣛⢧⣫⣜⢻⡜⣮⢛⡇⠀⠀⠀⠀⠀⠀⠈⣧⠢⠀⢸⣷⣿⠈⠀⠀⠀⠈⠀⠀⠀⣻⡜⣧⢯⢀⣿⣯⡾⣏⣿⡇⢠⠀⠀⠀⠀",
		  "⠀⠈⠻⣧⠻⣜⠶⣩⢞⡵⡭⢯⡁⠀⠀⠀⠀⠀⠐⠀⠸⡆⢂⣿⣿⣾⡆⠀⠀⠀⠂⠀⠀⠀⢸⣝⡮⢷⢸⣿⢟⡵⣻⣿⡇⠀⡀⠀⡆⠀",
		  "⠀⠀⣸⡯⣝⠮⣝⣣⢏⡾⣹⢷⠀⢠⠄⠀⡖⠀⢰⡇⠀⡆⠀⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⣟⣮⣽⢃⣿⣛⣮⠽⣿⣿⡇⠀⠀⠀⠀⠀",
		  "⠀⠀⣿⡱⢎⡽⢲⠭⣶⢹⣳⣿⠀⢸⠀⠀⡿⠀⢸⡄⠀⠇⠀⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢰⣟⡶⢣⣾⣳⡽⢮⣿⣿⣿⠀⠀⠇⠀⠰⠀",
		  "⠀⢀⡷⣙⠮⣜⢭⠳⣎⡳⣽⣿⡀⢸⣇⡀⣧⠀⣸⣅⠀⢧⠀⣿⣿⣿⡗⠀⠀⠀⠀⠀⠀⣼⡻⣣⣿⡾⣷⣛⣟⣾⢯⣿⠀⠀⠈⠀⠀⠀",
		  "⠀⢸⠲⣍⠞⡜⡮⣝⡲⣝⣿⣿⣷⠈⢧⠀⡇⢠⣷⠃⢸⡏⢰⣿⣿⣿⡟⣠⠂⠀⠀⠀⣸⡿⣵⣻⣿⣽⢳⣯⢾⡽⣿⣿⠀⠈⠄⠀⠠⠀",
		  "⠀⣍⡳⣌⠻⡼⣱⢎⡵⣾⣿⢻⣿⣷⣜⡇⡧⣸⡏⣠⣿⢳⣿⣿⣿⣿⡇⠁⠀⠀⠀⢀⡾⣼⣷⣿⣳⢯⣟⡾⣯⣽⣿⣿⠀⠡⢈⠐⠰⠀",
		  "⢰⢣⢳⡜⣽⡱⢧⣋⢶⡿⣭⢻⣿⣿⣿⣿⣷⣿⣷⣿⢹⣿⣿⣿⣿⣿⢁⠂⠀⠀⠀⢃⣿⣿⣿⣿⣟⣯⢿⣽⣳⣿⣿⣏⢐⠒⡠⠬⢔⡀",
		  "⣨⢧⡓⡾⣥⣛⠧⣞⡿⣝⢮⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⡡⠔⠈⠀⢺⣹⣿⡿⣽⣻⣿⣿⣷⣿⣿⣿⡇⢨⠐⢠⠁⡂⠄",
		  "⡳⣎⣽⣳⣳⢭⣛⣼⢻⡜⣧⢿⣿⣿⣿⣿⣿⣿⣟⡫⠆⢸⣿⣿⣿⣿⣿⠁⠂⢐⣶⣿⣟⣷⣻⡽⣟⣿⣿⣿⣿⣿⣿⠄⠂⠌⠄⡂⢁⣎",
		  "⣷⣹⡶⣯⣟⢮⣳⣏⢷⡹⣞⣿⣿⣿⣿⣿⣿⣿⣿⡄⠁⣸⣿⣿⣿⣿⣿⣮⣿⢿⣻⢾⡽⣾⣽⣿⣿⣿⣿⣿⣿⣿⣯⣤⡿⣶⣶⣾⣻⢿",
		  "⣧⣿⢿⣽⢾⣣⢟⣮⡳⢯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⢔⣿⣿⣿⣿⣿⡿⣿⡽⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣽⣳⣯⣳⣿⢿⣽⣾⣽⢯",
		  "⣿⣯⣿⢯⡿⣜⣯⢶⣛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠸⠻⣿⡿⠿⢛⡛⠩⠻⢿⣷⡿⣞⣿⣿⣿⣿⣿⣞⣷⣿⣷⣿⣿⣟⣯⢷⣻⣞⡿",
		  "",
		  "",
		  "*/",
		],
		"description": "kiyotaka"
},
	   	"FOR BUNNY" : {
		"prefix": "bunnygirl",
		"body": [
		  " /*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⢀⣀⣠⣤⣼⣿⣿⣿⣿⣿⣿⣿⣅⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣯⣽⣢⢤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⡍⠲⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠉⠉⢩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⢢⣈⠫⢄⠀⠀⠀⠀⠀⠀⢀⡄⠂⢄⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣽⣿⣿⣿⣿⣽⣿⣿⣿⣿⣷⡧⠀⠀⠀⠀⢀⠎⠀⠀⠀⢃⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣟⣣⠀⠀⠀⡎⠀⠀⠀⠀⠀⡆⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⡋⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡔⡄⠀⠁⠀⠀⠀⠀⠀⢰⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⠿⠋⠁⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⡇⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡇⢰⠇⠀⠀⠀⠀⠀⡘⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⣼⣼⣿⣿⠿⣿⣿⣿⡿⢹⣿⣿⣿⣿⣿⣿⡽⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠎⠦⡀⠀⠀⠀⢀⠇⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢢⣿⡇⣼⣧⣶⣿⣿⣿⠁⢸⢿⣿⣿⣿⣿⣿⣷⡘⣷⡹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠧⡙⠀⠑⢄⣀⠤⠂⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣟⣼⣿⣿⣿⣿⣿⣿⠀⠀⢛⣿⣿⣿⣿⣿⡿⣿⡬⠿⣾⡻⣿⣿⣿⣿⣿⣿⣿⣿⣿⢯⣿⣿⣿⣿⣿⣻⡆⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⣿⢻⣿⣿⣿⣿⣿⣿⣿⡏⠉⠉⠻⢿⣿⣿⣿⣿⣜⢿⣮⡙⠷⣦⣉⠓⢿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠤⠤⠤⠤⣀⠀⠘⠀⠀⣿⢸⢿⣿⣿⣿⣿⣿⠘⢿⠈⠁⠐⠄⠙⢟⢿⣿⣿⣦⡵⣟⣶⣽⣿⣿⣿⣿⣿⣿⣿⣿⣯⣾⣿⣿⣿⣿⣼⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠑⠆⠀⠀⣿⠀⣿⣿⣿⣿⣿⣿⣀⣬⣧⣖⣢⠄⠀⠀⠀⠈⠑⠈⠹⠿⠋⠘⣿⣿⣿⡆⣿⣿⣿⡏⡧⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠊⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠀⢿⠀⢹⣿⣿⣿⣿⣿⣿⡿⠻⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢮⠴⢃⣿⣿⣿⣿⣷⡟⣿⣿⣿⣿⣿⣟⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠄⠸⡆⡄⢿⣿⣿⣿⣿⣿⡻⢄⠙⢿⣻⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⢻⣿⣿⣿⢈⣷⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⠐⠹⣵⠀⣿⣿⣿⣿⣿⢿⠦⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⡠⠞⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡷⠀⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠘⢦⣿⣿⣿⣿⣿⣮⣆⠀⠀⠀⠀⠀⠈⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢣⠀⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣦⣤⡤⠀⠀⠀⠀⢀⣀⣀⣀⡀⠀⠀⢀⠴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡌⡆⠀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡅⠀⠀⠀⣾⠇⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠘⡀⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⠀⠀⣸⡟⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣢⢄⠀⠀⢀⣤⣶⣿⢟⣿⣿⣿⣿⠰⢸⠾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⢡⠀⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠰⡀⠀⠀⠀⠀⠀⠀⢀⠜⠀⠀⠀⣰⡟⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠉⣫⢻⡿⠛⢁⢾⣿⣿⣿⡇⠇⡜⠀⡿⣻⣿⣿⣿⣿⣿⣿⣿⣿⣻⡈⡆⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⡠⠔⠁⠀⠀⠀⣰⡟⠀⠀⣟⣿⣿⣿⣿⣿⣿⠿⠛⠋⠉⠉⠛⠻⢗⠏⠏⢸⢇⢠⠟⣾⣿⣿⣿⣱⠊⠀⠀⡿⡞⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢸⠀⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠈⠁⠀⠀⠀⠀⢀⡾⠋⠀⠀⣸⠇⣿⣹⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⡈⠀⠀⠸⢻⠋⢸⣿⣿⣿⢿⠃⠀⠀⠀⣇⠗⢿⡇⢹⣿⣿⢿⣿⣿⣿⣿⣏⡆⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠛⠁⠀⠀⢠⡟⢀⣿⣿⣿⣿⣿⡟⣄⠀⠀⠀⠀⢠⣴⣧⣤⣄⣠⠣⣀⣿⣿⣿⣟⠎⠀⠀⠀⠀⣽⠀⠘⣿⠊⠫⡺⣷⣌⠉⡿⢿⣿⡇⠀⠀⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠊⠀⠀⠀⢀⡠⣾⣁⣼⣿⣿⣿⢹⣿⡇⠈⠑⠂⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⠇⡜⠘⡄⠀⠹⣧⠀⠈⠪⢙⢻⠷⠦⠿⣿⡄⠀⠀",
		  "⠀⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠊⠀⣀⠔⣒⣵⣾⣿⣿⣿⣿⣿⣿⡇⢸⣿⠀⠀⡇⠀⠀⠀⠀⣿⣿⣿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⢋⡼⠔⠀⠉⢄⡀⠙⣧⠀⣀⡴⠉⠉⠉⠉⠹⣷⡀⠀",
		  "⠀⠈⢏⣷⣮⣕⠢⠀⠀⠀⠀⢠⠞⢀⠔⢉⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⣸⠃⠀⠠⠃⠀⠀⠀⢐⡨⠋⠀⣗⡄⢸⣿⣿⡿⡿⣿⡿⢣⠊⠀⠀⠀⠀⠀⠈⠑⠚⠻⣿⣄⣀⡀⠀⢀⣠⣿⣗⡀",
		  "⠀⠀⠀⢻⣿⣿⣿⣄⢂⠀⢠⣟⠔⠁⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢀⠏⣀⠞⠀⠀⠀⠀⠀⠈⠀⠀⠀⣿⠀⢸⣿⣟⠀⢣⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠛⠛⠛⠊⢸⣿⡝",
		  "⠀⠀⠀⠀⢻⣿⣿⣿⣆⢃⢸⡏⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣾⣿⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣧⢸⣿⡟⠀⠸⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣷",
		  "⠀⠀⠀⠀⠀⢻⣿⣿⣿⡞⡔⣣⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⣠⠀⠘⠻⡼⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⢻⣿",
		  "⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠑⠌⠢⠀⣀⣀⠀⠀⠀⠀⠀⠀⣽⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⢸⣿",
		  "⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣰⣿⣿⣯⣆⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⢸⣿",
		  "⠀⠀⠀⠀⠀⠀⠀⠈⣏⠻⢿⣿⣿⣿⣿⣿⣿⡇⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠆⠀⢀⣠⢰⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⡟⢸⡟",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⢸⢇⠈⢿⣿⣿⣿⣿⣿⠁⢀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⡈⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⢠⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡟⢁⡟⠀",
		  "⠀⠀⠀⠀⠀⠀⠀⠀⠘⠀⠆⠈⢿⣿⣿⣿⡇⠀⢸⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⡎⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣰⣏⣀⣊⣀⣀*/"
		],
		"description": "bunnygirl"
},
		"dsu": {
		"prefix": "dsu",
		"body": [
			"class UnionFind",
			"{",
			"    private: vector<int> p, rank;",
			"    public:",
			"",
			"        UnionFind(int n)",
			"        {",
			"            rank.assign(n,0); p.assign(n,0);",
			"            iota(p.begin(),p.end(),0);",
			"        }",
			"",
			"        int findSet(int i){ return (p[i] == i) ? i : p[i] = findSet(p[i]);}",
			"",
			"        bool isSameSet(int i, int j){ return findSet(i) == findSet(j);}",
			"",
			"        void unionSet(int i, int j)",
			"        {",
			"            if(!isSameSet(i,j))",
			"            {",
			"                int x = findSet(i), y = findSet(j);",
			"                if(rank[x] > rank[y]) p[y] = x;",
			"                else ",
			"                {",
			"                    p[x] = y;",
			"                    if(rank[x] == rank[y]) rank[y]++;",
			"                }",
			"            }",
			"        }",
			"};"
		],
		"description": "dsu"
},
	  "Hashing Struct": {
		"prefix": "hashing",
		"body": [
			"struct Hashing {",
			"\tstring s;",
			"\tint n;",
			"\tint primes;",
			"\tvector<int> hashPrimes = {1000000009, 100000007};",
			"\tconst int base = 31;",
			"\tvector<vector<int>> hashValues;",
			"\tvector<vector<int>> powersOfBase;",
			"\tvector<vector<int>> inversePowersOfBase;",
			"\tHashing(string a) {",
			"\t\tprimes = sz(hashPrimes);",
			"\t\thashValues.resize(primes);",
			"\t\tpowersOfBase.resize(primes);",
			"\t\tinversePowersOfBase.resize(primes);",
			"\t\ts = a;",
			"\t\tn = s.length();",
			"\t\tfor (int i = 0; i < sz(hashPrimes); i++) {",
			"\t\t\tpowersOfBase[i].resize(n + 1);",
			"\t\t\tinversePowersOfBase[i].resize(n + 1);",
			"\t\t\tpowersOfBase[i][0] = 1;",
			"\t\t\tfor (int j = 1; j <= n; j++) {",
			"\t\t\t\tpowersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];",
			"\t\t\t}",
			"\t\t\tinversePowersOfBase[i][n] = mminvprime(powersOfBase[i][n], hashPrimes[i]);",
			"\t\t\tfor (int j = n - 1; j >= 0; j--) {",
			"\t\t\t\tinversePowersOfBase[i][j] = mod_mul(inversePowersOfBase[i][j + 1], base, hashPrimes[i]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor (int i = 0; i < sz(hashPrimes); i++) {",
			"\t\t\thashValues[i].resize(n);",
			"\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\thashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];",
			"\t\t\t\thashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvector<int> substringHash(int l, int r) {",
			"\t\tvector<int> hash(primes);",
			"\t\tfor (int i = 0; i < primes; i++) {",
			"\t\t\tint val1 = hashValues[i][r];",
			"\t\t\tint val2 = l > 0 ? hashValues[i][l - 1] : 0LL;",
			"\t\t\thash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), inversePowersOfBase[i][l], hashPrimes[i]);",
			"\t\t}",
			"\t\treturn hash;",
			"\t}",
			"};"
		],
		"description": "hashing"
	},
	"segtree": {
	"prefix": "segtree",
	"body": [
		"template<typename Node, typename Update>",
		"struct SegTree {",
		"    vector<Node> tree;",
		"    vector<int> arr; // type may change",
		"    int n;",
		"    int s;",
		"    SegTree(int a_len, vector<int> &a) // change if type updated",
		"    { ",
		"        arr = a;",
		"        n = a_len;",
		"        // s = 4 * n;",
		"        s = 1;",
		"        while(s < 2 * n){",
		"            s = s << 1;",
		"        }",
		"        tree.resize(s); ",
		"        fill(all(tree), Node());",
		"        build(0, n - 1, 1);",
		"    }",
		"    ",
		"    void build(int start, int end, int index)",
		"    {",
		"        if (start == end)   { // leaf node",
		"            tree[index] = Node(arr[start], start); // how is the node populated",
		"            return;",
		"        }",
		"        int mid = (start + end) / 2;",
		"        build(start, mid, 2 * index);",
		"        build(mid + 1, end, 2 * index + 1);",
		"        tree[index].merge(tree[2 * index], tree[2 * index + 1]); // what is merge",
		"    }",
		"    ",
		"    ",
		"    ",
		"    void update(int start, int end, int index, int query_index, Update &u)  // Never Change this",
		"    {",
		"        if (start == end) { // leaf node",
		"            u.apply(tree[index]);",
		"            return;",
		"        }",
		"        int mid = (start + end) / 2;",
		"        if (mid >= query_index)",
		"            update(start, mid, 2 * index, query_index, u);",
		"        else",
		"            update(mid + 1, end, 2 * index + 1, query_index, u);",
		"        tree[index].merge(tree[2 * index], tree[2 * index + 1]);",
		"    }",
		"    ",
		"    Node query(int start, int end, int index, int left, int right) { // Never change this",
		"        if (start > right || end < left)",
		"            return Node();              // default value ",
		"        if (start >= left && end <= right)",
		"            return tree[index];",
		"        int mid = (start + end) / 2;",
		"        Node l, r, ans;",
		"        l = query(start, mid, 2 * index, left, right);",
		"        r = query(mid + 1, end, 2 * index + 1, left, right);",
		"        ans.merge(l, r);",
		"        return ans;",
		"    }",
		"    ",
		"    void make_update(int arrIndex, int val) {  // pass in as many parameters as required",
		"        Update new_update = Update(val); // may change",
		"        update(0, n - 1, 1, arrIndex, new_update);",
		"    }",
		"    ",
		"    Node make_query(int left, int right) {",
		"        return query(0, n - 1, 1, left, right);",
		"    }",
		"};",
		"struct Node1 {",
		"    int val; // may change",
		"    Node1() { // Identity element",
		"        val = 0;    // may change",
		"    }",
		"    Node1(int p1, int index) {  // Actual Node",
		"        val = p1; // may change",
		"    }",
		"    void merge(Node1 &l, Node1 &r) { // Merge two child nodes",
		"        val = l.val + r.val;  // may change",
		"    }",
		"};",
		"struct Update1{",
		"    int val;",
		"    Update1(int x){",
		"        val = x;",
		"    }",
		"    void apply(Node1 &a1){",
		"        a1.val = val; // a.val (value taken in Node1, if it were a vector you would use a.v )",
		"    }",
		"};"
	],
	"description": "segtree"
},
	"square_root": {
	"prefix": "root",
	"body": [
		"    auto get = [&](int n){",
		"        int l = 0,r = 1e10;",
		"        int ans = 0;",
		"        while (l <= r){",
		"            int mid = (l + r)/2ll;",
		"            if(mid * 1ll * mid <= n) {",
		"                ans = mid;",
		"                l = mid + 1;",
		"            }",
		"            else{",
		"                r = mid - 1;",
		"            }",
		"        }",
		"        return ans;",
		"    };"
	],
	"description": "square_root",
	},
	"my_cht": {
	"prefix": "my_cht",
	"body": [
		"struct Line {",
		"  ld m, b;",
		"  ld operator()(ld x) { return m * x + b; }",
		"} a[C * 4];",
		"",
		"void insert(int l, int r, Line seg, int o=0) {",
		"  if(l + 1 == r) {",
		"    if(seg(l) > a[o](l)) a[o] = seg;",
		"    return;",
		"  }",
		"  int mid= (l + r) >> 1, lson = o * 2 + 1, rson = o * 2 + 2;",
		"  if(a[o].m > seg.m) swap(a[o], seg);",
		"  if(a[o](mid) < seg(mid)) {",
		"    swap(a[o], seg);",
		"    insert(l, mid, seg, lson);",
		"  }",
		"  else insert(mid, r, seg, rson);",
		"}",
		"",
		"ld query(int l, int r, int x, int o=0) {",
		"  if(l + 1 == r) return a[o](x);",
		"  int mid = (l + r) >> 1, lson = o * 2 + 1, rson = o * 2 + 2;",
		"  if(x < mid) return max(a[o](x), query(l, mid, x, lson));",
		"  else return max(a[o](x), query(mid, r, x, rson));",
		"}"
	],
	"description": "my_cht"
	},
	"centroid_decomposition": {
	"prefix": "centroid_decomposition",
	"body": [
		"vector<vector<int>> g(N);",
		"vector<int> sz(N), done(N), parent(N);",
		"int dep[N], Par[N][M];",
		" ",
		"void dfs(int cur, int par = -1){",
		"    if(par != -1){",
		"        dep[cur] = dep[par] + 1;",
		"    }",
		"    Par[cur][0] = (par == -1 ? cur : par);",
		"    for (int j = 1; j < M; j++) Par[cur][j] = Par[Par[cur][j - 1]][j - 1];",
		"",
		"    for(auto &x : g[cur]){",
		"        if(x != par){",
		"            dfs(x, cur);",
		"        }",
		"    }",
		"}",
		"",
		"void get(int cur, int par = -1){",
		"    sz[cur] = 1;",
		"",
		"    for(auto &x : g[cur]){",
		"        if(x == par || done[x]) continue;",
		"",
		"        get(x, cur);",
		"        sz[cur] += sz[x];",
		"    }",
		"}",
		"",
		"int centroid(int cur, int par, int tot){",
		"    ",
		"    for(auto &x : g[cur]){",
		"        if(x == par || done[x]) continue;",
		"",
		"        if(2 * sz[x] > tot){",
		"            return centroid(x, cur, tot);",
		"        }",
		"    }",
		"",
		"    return cur;",
		"}",
		"",
		"void decompose(int cur, int par = -1){",
		"    get(cur);",
		"",
		"    int c = centroid(cur, par, sz[cur]);",
		"    done[c] = 1;",
		"    parent[c] = par;",
		"",
		"    for(auto &x : g[c]){",
		"        if(!done[x]){",
		"            decompose(x, c);",
		"        }",
		"    }",
		"}",
		" ",
		"int LCA(int u, int v) {",
		"    if (u == v) return u;",
		"    if (dep[u] < dep[v]) swap(u, v);",
		"    // u is deeper",
		"",
		"    int diff = dep[u] - dep[v];",
		"    for (int j = M - 1; j >= 0; j--){",
		"        if ((diff >> j) & 1) u = Par[u][j];",
		"    }",
		" ",
		"    for (int j = M - 1; j >= 0; j--){",
		"        if (Par[u][j] != Par[v][j]){",
		"            u = Par[u][j];",
		"            v = Par[v][j];",
		"        }",
		"    }",
		"",
		"    return (u != v ? Par[u][0] : u);",
		"}",
		"",
		"int dist(int u, int v){",
		"    return dep[u] + dep[v] - 2int * dep[LCA(u, v)];",
		"}",
		"",
		""
	],
	"description": "centroid_decomposition"
	},
}
